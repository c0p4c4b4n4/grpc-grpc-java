In gRPC Java, newStub, newBlockingStub, and newFutureStub are used to create different types of client stubs for interacting with a gRPC service, each offering a distinct way of handling RPC calls:
newBlockingStub(Channel channel) (Blocking/Synchronous Stub):
Behavior: This stub makes synchronous RPC calls. When a method on a BlockingStub is invoked, the client thread will block and wait for the server to send a response or an error.
Use Case: Suitable for simple request-response scenarios where the client can afford to wait for the server's reply, and where immediate processing of the response is required before proceeding.
Example:
Java

        MyServiceGrpc.MyServiceBlockingStub blockingStub = MyServiceGrpc.newBlockingStub(channel);
        MyResponse response = blockingStub.myMethod(MyRequest.newBuilder().build());
        // Process response
newStub(Channel channel) (Asynchronous/Non-Blocking Stub):
Behavior: This stub makes asynchronous RPC calls. Instead of blocking, methods on an AsyncStub return void and require a StreamObserver as an argument to handle responses or errors. Responses are delivered to the onNext, onError, or onCompleted methods of the provided StreamObserver callback.
Use Case: Essential for streaming RPCs (client-side streaming, server-side streaming, and bi-directional streaming) and for scenarios where the client needs to perform other tasks while waiting for the server's response, avoiding thread blocking.
Example:
Java

        MyServiceGrpc.MyServiceStub asyncStub = MyServiceGrpc.newStub(channel);
        asyncStub.myStreamingMethod(new StreamObserver<MyResponse>() {
            @Override
            public void onNext(MyResponse response) {
                // Process response
            }
            @Override
            public void onError(Throwable t) {
                // Handle error
            }
            @Override
            public void onCompleted() {
                // Call completed
            }
        });
newFutureStub(Channel channel) (ListenableFuture Stub):
Behavior: This stub also makes asynchronous RPC calls but returns a ListenableFuture (from Guava) for each method invocation. This ListenableFuture can then be used to retrieve the result of the RPC call once it's available, either by blocking with get() or by attaching callbacks.
Use Case: Offers a middle ground between blocking and fully asynchronous stubs. It's useful when you want to perform other operations while the RPC is in progress but still want a structured way to handle the eventual result, potentially using Guava's Futures utilities.
Example:
Java

        MyServiceGrpc.MyServiceFutureStub futureStub = MyServiceGrpc.newFutureStub(channel);
        ListenableFuture<MyResponse> future = futureStub.myMethod(MyRequest.newBuilder().build());
        // Do other work
        try {
            MyResponse response = future.get(); // Blocks until response is available
            // Process response
        } catch (InterruptedException | ExecutionException e) {
            // Handle error
        }
In summary:
newBlockingStub: Synchronous, blocks the client thread.
newStub: Asynchronous, uses StreamObserver callbacks for handling responses, ideal for streaming.
newFutureStub: Asynchronous, returns ListenableFuture for managing the eventual result.