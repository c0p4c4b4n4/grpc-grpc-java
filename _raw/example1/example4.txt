In gRPC-Java, Bidirectional Streaming (where both sides stream independently) is only natively supported by the Asynchronous Stub (EchoServiceStub). The BlockingStub and FutureStub do not support bidirectional methods because they are architecturally designed for request-response patterns.
To meet your requirements for three client variants, we use the async stub for the core logic and bridge it for sync and future-like behaviors.
1. Protobuf Definition
Save this as echo.proto.
protobuf
syntax = "proto3";
option java_multiple_files = true;
package com.example.grpc;

service EchoService {
  rpc BidirectionalStreamingEcho(stream EchoRequest) returns (stream EchoResponse);
}

message EchoRequest { string message = 1; }
message EchoResponse { string message = 1; }
Use code with caution.

2. gRPC Server Implementation
The server returns an observer to handle incoming client messages and uses the responseObserver to push responses back at any time.
java
public class EchoServer {
    public static void main(String[] args) throws Exception {
        Server server = ServerBuilder.forPort(50051)
                .addService(new EchoServiceImpl())
                .build().start();
        server.awaitTermination();
    }

    static class EchoServiceImpl extends EchoServiceGrpc.EchoServiceImplBase {
        @Override
        public StreamObserver<EchoRequest> bidirectionalStreamingEcho(StreamObserver<EchoResponse> responseObserver) {
            return new StreamObserver<EchoRequest>() {
                @Override
                public void onNext(EchoRequest req) {
                    // Business logic: Echo back immediately or process
                    responseObserver.onNext(EchoResponse.newBuilder()
                            .setMessage("Server: " + req.getMessage()).build());
                }

                @Override public void onError(Throwable t) { t.printStackTrace(); }
                @Override public void onCompleted() { responseObserver.onCompleted(); }
            };
        }
    }
}
Use code with caution.

3. Client Variants
A. Asynchronous (Standard) Client
This is the native way to handle bidirectional streams using StreamObserver.
java
EchoServiceGrpc.EchoServiceStub asyncStub = EchoServiceGrpc.newStub(channel);
StreamObserver<EchoRequest> requestObserver = asyncStub.bidirectionalStreamingEcho(new StreamObserver<EchoResponse>() {
    @Override public void onNext(EchoResponse value) { System.out.println("Received: " + value.getMessage()); }
    @Override public void onError(Throwable t) { t.printStackTrace(); }
    @Override public void onCompleted() { System.out.println("Stream closed by server."); }
});

requestObserver.onNext(EchoRequest.newBuilder().setMessage("Msg 1").build());
requestObserver.onNext(EchoRequest.newBuilder().setMessage("Msg 2").build());
requestObserver.onCompleted();
Use code with caution.

B. Synchronous (Simulated via Blocking)
Since BlockingStub does not support this, we use a CountDownLatch to force the calling thread to wait until the stream is complete.
java
CountDownLatch latch = new CountDownLatch(1);
StreamObserver<EchoRequest> requestObserver = asyncStub.bidirectionalStreamingEcho(new StreamObserver<EchoResponse>() {
    @Override public void onNext(EchoResponse value) { System.out.println("Sync Received: " + value.getMessage()); }
    @Override public void onError(Throwable t) { latch.countDown(); }
    @Override public void onCompleted() { latch.countDown(); }
});

requestObserver.onNext(EchoRequest.newBuilder().setMessage("Sync Ping").build());
requestObserver.onCompleted();
latch.await(); // Blocks until the entire stream is finished
Use code with caution.

C. ListenableFuture Variant (Custom Bridge)
A FutureStub cannot be used for streaming. To provide a ListenableFuture interface, we use a SettableFuture to signal when the entire stream has finished or if an error occurred.
java
SettableFuture<Void> streamFuture = SettableFuture.create();
StreamObserver<EchoRequest> requestObserver = asyncStub.bidirectionalStreamingEcho(new StreamObserver<EchoResponse>() {
    @Override public void onNext(EchoResponse value) { /* Handle streaming data */ }
    @Override public void onError(Throwable t) { streamFuture.setException(t); }
    @Override public void onCompleted() { streamFuture.set(null); }
});

requestObserver.onNext(EchoRequest.newBuilder().setMessage("Future Ping").build());
requestObserver.onCompleted();
// Use streamFuture to track the status of the connection
