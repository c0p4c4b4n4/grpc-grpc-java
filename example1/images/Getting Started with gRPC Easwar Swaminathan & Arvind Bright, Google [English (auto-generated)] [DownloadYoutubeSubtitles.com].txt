[Music]

hey everyone I'm Arvin and this is iswar

we both are software Engineers on the

grpc team at Google we work on building

new features fixing bugs and answering

questions posted by our external

users what is

grpc but before that what is an

RPC an RPC or a remote procedure call is

a way for one program to call a function

that gets executed on another program

the call function might execute in a

different process on the same machine or

on a different machine reachable via the

network at this point we're going to

assume that folks here have at least a

high level conceptual understanding of

what an RPC is if you've seen a sequence

diagram that looks something like this

or if you understand what is happening

here then you're good to go if not it

might be a good idea to pause this video

here familiarize yourself with rpcs and

come

back grpc is a modern high performance

Cloud native RPC framework what that

means is grpc general purpose can be run

on Linux Windows Mac OS Android iOS Etc

also supports x86 and arm

architectures drpc can be run on a

server on your mobile device in the

browser and also on embed

systems grpc is language agnostic this

is a Core Essence of

grpc we support C C++ go Java python

node cop to name a

few grpc is open source software and is

accepted to Cloud native Computing

Foundation since

2017 grpc has been built to power use

cases to the last mile of computing it

relies on http2 for the transport and

uses protuff as the interface definition

language this results in Services where

the apis are well- defined and the

communication between the services are

of low latency and high performance

Google has had an internal RPC framework

called stubby for decades stubby is been

used at a planet scale for communication

between services in different data

centers in 2015 Google decided to build

the next version of stubby and also make

it open source the result was

grpc grpc is production ready and is

widely used within Google and in the

industry further we go any further Isa

will let us know about these two

technologies that form the foundation of

grpc http2 started as a project named

Speedy whose motivation was a faster web

HTTP 2's performance gains can be put

down to three major things requests and

responses are transmitted in binary

format different request and response

messages can be multiplexed on a single

connection headers are compressed by

default using hpack grpc uses http2 as

its transport what this means is that

grpc requests and responses are

transmitted as http2

frames protocol buffers or Proto Buffs

is an open source project for

serializing structured data you can

think of it as being similar to XML or

Json but faster smaller and simpler rabu

supports an interface definition

language or ideal that allows developers

to define the contract between the

client and the server this contract not

only includes the methods exposed by the

server it also includes the structure of

the request and response messages

exchanged between the client and the

server the prot of Ideal is strongly

typed and supports forwards and

backwards

compatibility this is key to be able to

perform staged rollouts on your Fleet of

microservices protuff supports tools to

generate client and serers side code

from this ideal for multiple programming

languages this allows developers to

write services in their language of

choice and still be able to interrupt

with other services protuff also ships

with runtime libraries which perform

serialization and

deserialization these are highly

optimized for performance

now that we've seen what grpc is and

what it's built on top of Arin will get

us started with building a microservices

based application using

grpc now imagine the speeds of plays in

Sunnyvale California but they are in

need of an online auto processing

application that needs to be accessible

Via Mobile and

desktop micros Serv has been around for

a while microservices based architecture

comes with a ton of advantages

but also come with its own challenges

especially when it comes to service to

service

communication drpc was built with

microservices in

mind in the next few slides we will show

you how we can build an application as a

set of micros services that communicate

with each other using

grpc as software developers we always

want to see that beautiful system design

diagram let us start by splitting the

app into microservices and designing the

role of each Serv

service the order Management Service is

the user facing component and will

support an API to order a pizza and to

track the status of an order the

inventory service checks if an order can

be satisfied based on the current

stock the payment service helps process

user

payments the processing service manages

the life cycle of an order now Isa will

take us through how to start by building

the API contract using Proto files

and how we can generate codee and Link

our server SL client to the

system Ruff allows you to define the

contract between the client and the

server here we've defined the API to

place an order for a pizza the name of

the RPC method is place order it takes a

request message of type order request

and returns a response message of type

order

response request and response messages

are types themselves that allow you to

group any number of fields in them this

RPC is an example of a unary RPC which

is used for simple request and response

scenarios we will look at other RPC

types later on in this

video the order request message contains

fields to describe the order we've

defined fields to represent the size of

the pizza the toppings that go on top of

it and the customer making the order the

the order response message contains the

status of the order and an ID to

subsequently track the order this is an

example of how complex Proto messages

can be built by composing simpler

ones in a restful World there are two

ways to describe the contract between

the client and the server a human

readable document describing the API or

a yaml file using the open API spec both

can get quite verbose we tried writing a

yaml spec for the place order API and it

turned out to be over 300

lines now that we've defined our API in

a Proto file it's time to compile it

using the protoc compiler this is a

single command to generate language

findings for both server and client in

go Arvin will now show us what the

generated code looks like and how to

integrate it with your client and server

application

code the generated language bindings are

actually quite readable the most

important takeaway from the generated

code on the server side is that this

interface contains methods corresponding

to the methods defined in the service

definition since we Define only one

method in our service we get an

interface with a single method

here the server application must provide

the implementation for this method it

typically involves performing all the

required business logic which could

include making grpc calls to other

services and finally returning a result

to the

call once we have the service

implementation ready we have to create a

grpc server instance register our

service with the grpc server and start

serving the generated language bindings

on the client side Define an interface

that's similar to the one on the server

side it contains methods matching those

defined in the

service the implementation for this

service is also provided by the

generated code and we refer to this

implementation as the client stub which

takes care of converting calls from the

client application into

rpcs on the client side the first thing

the application would do is to create a

grpc channel a grpc channel represents a

virtual connection to the

server once a channel is created the

application needs to create the stub by

calling the function provided by the

generat code once the is created making

an RPC is as simple as invoking the

corresponding method on the client's tub

the RPC handles all the Magic by

serializing and shipping the request to

the server once it receives a response

from the server it deserializes it and

makes it available to the client

application now that we have a better

understanding of how to define the

service in prot of syntax and how to

generate language specific bindings

let's switch back to a pizza application

let's see how a user request is handled

end to end user makes a place order RPC

call to the order service which as part

of its business logic interacts with

other services before returning a

response to the user it first makes an

RPC call to the inventory service to

check if an order can be satisfied with

the current inventory the inventory

service API will typically be defined in

its own prototo file here the order

service acts as a client of the

inventory service and therefore would

use the client tuub from the Inventory

Services generated code to make this RPC

the inventory service sends a response

which indicates whether the order can be

satisfied based on this response the

order service makes another RPC call

this time to the payment service to

process the customer's payment like the

inventory service the payment service

API will be defined in its own prototo

file payment payment service sends a

response containing the status of the

payment finally the order service makes

an RPC to the processing service to

dispatch the order the processing

service sends a response containing an

ID to track the order at any point

during this sequence of rpcs the order

service might return an error to the

user for example if the order could not

be processed based on the current

inventory or if the payment processing

failed but if everything went well the

order service returns a response back to

the user that contains the ID of the

order all rpcs shown so far are unary

rpcs which are of the request response

type Arwin will now take us through

other RPC types supported by

grpc we already looked at what a unary

RPC looks like it is simple and more

similar to a typical rest call there are

other three types of rpcs the first is

where the client sends a single single

message to the server and the server

returns a stream of messages as its

response this is called server streaming

rpcs the second type is where the client

sends a stream of messages to the server

as part of the request and the server

comes back with a single response this

is called client streaming

rpcs the last type is B directional

streaming rpcs where each side can send

a stream of messages to the other side

independent of each

other let's do Define a server streaming

RPC to stream order status to the client

this RPC accepts a status request

message as input and returns a stream of

status response

messages the server application will

send a new message on the stream

whenever the status of the pizza order

changes the status request message is a

simple message containing the order ID

for

tracking the status response message

contains the current status of the order

and since we have Define the stream

order status RPC as a server streaming

RPC the client will receive status

updates from the server until the server

decides to close the stream let's look

at the flow for the server streaming RPC

the user makes the RPC call to the aut

Management Service the RPC returns a

stream from which the client can read

messages sent by the server the autom

Management Service makes a streaming RPC

call to processing service the

processing service returns a stream from

which the order Management Service can

read status updates and push the same

onto the stream to the

user now over to

ISU so far we've seen how we can

Implement some unary and streaming rpcs

developing and running a microservices

based application involves more than

just making a few RPC calls grpc is

built with microservices in mind and

supports a ton of features some are

listed here but grp PC supports much

more instead of going into the details

of each of these features what we want

to emphasize here is that grpc is

extensible features in grpc are

typically supported through a plug-in

mechanism which allows developers to

bring their own implementation grpc

typically ships with one or two same

default implementations for each of

these features for example if we

consider service Discovery grpc ships

with a dns-based service Discovery

mechanism but if you want to use a

different service Discovery mechanism in

your mesh gpc's plug-in mechanism

enables you to bring your own service

Discovery implementation which caters to

your needs similarly if we consider load

balancing grpc ships with a few simple

load balancing policies but you're free

to bring your own load balancing

policies we have a ton of examples in

each of our language repositories in

GitHub which go over these features be

sure to check them out

we'll be back with more videos and

always thanks for

[Music]

watching


