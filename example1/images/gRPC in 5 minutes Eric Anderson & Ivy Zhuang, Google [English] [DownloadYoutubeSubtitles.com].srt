1
00:00:02,220 --> 00:00:05,060
[music]

2
00:00:09,740 --> 00:00:14,160
Hi, I'm Eric Anderson. And I'm Ivy Zhuang. We are Software Engineers on the gRPC
team at Google

3
00:00:14,160 --> 00:00:20,760
We work most on the Java implementation
of gRPC and Proxyless Service Mesh

4
00:00:20,760 --> 00:00:25,199
as an overview, gRPC supports a variety
of languages and platforms with rich

5
00:00:25,199 --> 00:00:28,619
features, making it perfect for
microservices and distributed

6
00:00:28,619 --> 00:00:32,700
applications
gRPC stands for gRPC Remote Procedure

7
00:00:32,700 --> 00:00:37,800
Call. It is a CNCF incubating project
which is the same open-source foundation

8
00:00:37,800 --> 00:00:45,379
as Kubernetes. Fun fact, gRPC also stands
for our golden retriever mascot, pancakes

9
00:00:45,420 --> 00:00:50,960
let me first walk you through a "hello
world" example in gRPC

10
00:00:51,719 --> 00:00:56,460
this is the protobuf file that defines
the API of the service called Greeter

11
00:00:56,460 --> 00:01:00,600
and the request and response message
data structures

12
00:01:00,600 --> 00:01:05,220
for those of you who are new to protocol
buffers, it is an easy and efficient

13
00:01:05,220 --> 00:01:12,260
mechanism to serialize structured data
so that it can be transmitted over wire

14
00:01:12,260 --> 00:01:17,580
specifically, at compile time, the
protobuf generator generates code to

15
00:01:17,580 --> 00:01:22,799
interface with language specific runtime
libraries and the serialization format

16
00:01:22,799 --> 00:01:26,939
for the data that is written to the
network connection

17
00:01:26,939 --> 00:01:31,680
next, you write your application class
based on the protobuf generated source

18
00:01:31,680 --> 00:01:38,340
code that handles a gRPC request
as a demo service, here we attach "Hello"

19
00:01:38,340 --> 00:01:41,759
string and echo the name field in the
request

20
00:01:41,759 --> 00:01:45,360
then we write the code to start the
server application

21
00:01:45,360 --> 00:01:51,420
the main class will start a gRPC server
that is listening on port 50051 for

22
00:01:51,420 --> 00:01:57,420
client connection when it starts running
the last piece of code is the main class

23
00:01:57,420 --> 00:02:03,180
on the client side. it sends a request
through a gRPC channel towards the gRPC

24
00:02:03,180 --> 00:02:08,759
server that we just sprung up
it logs the response data

25
00:02:08,759 --> 00:02:14,099
this concludes our mini demo. this demo
is simple. but this is exactly the same

26
00:02:14,099 --> 00:02:19,560
predecessor library at Google that
supports extremely high qps at the 10 to

27
00:02:19,560 --> 00:02:23,580
the 10th power
with that in mind, let's look at some of

28
00:02:23,580 --> 00:02:26,720
the features of gRPC

29
00:02:27,180 --> 00:02:33,060
gRPC is available in many languages
there's Go, Java, C++, Python, and

30
00:02:33,060 --> 00:02:37,620
many more. gRPC can communicate across
languages with a service definition and

31
00:02:37,620 --> 00:02:41,280
generated code, making the experience
natural in each language

32
00:02:41,280 --> 00:02:47,099
it is also available on many platforms
whether running on Linux, Mac, Windows, or

33
00:02:47,099 --> 00:02:50,819
on mobile devices running iOS and
Android. gRPC can communicate between

34
00:02:50,819 --> 00:02:55,440
them all. you get to choose the language
and platforms for your system

35
00:02:55,440 --> 00:03:01,200
gRPC is built on HTTP/2 which is an IETF
standard. that makes it compatible with

36
00:03:01,200 --> 00:03:05,700
many load balancers and proxies.
HTTP/2 reduces the number of TCP

37
00:03:05,700 --> 00:03:10,379
connections, is binary, it includes header
compression, all of which help make gRPC

38
00:03:10,379 --> 00:03:14,940
high performance, reduce latency, and make
better use of resources

39
00:03:14,940 --> 00:03:19,080
but gRPC also supports direct
client-side load balancing, so when

40
00:03:19,080 --> 00:03:22,500
appropriate, it can run without the
proxies, reducing the number of

41
00:03:22,500 --> 00:03:24,959
components to manage and increasing
performance

42
00:03:24,959 --> 00:03:30,420
This applies even with service meshes. gRPC
has support to directly communicate with

43
00:03:30,420 --> 00:03:34,319
centralized configurations service
discovery servers like Istio and Google

44
00:03:34,319 --> 00:03:38,280
Cloud's Traffic Director that lets it
participate in a mesh without the

45
00:03:38,280 --> 00:03:43,860
headache and cost of sidecar proxies
as you learn gRPC, you'll find it is

46
00:03:43,860 --> 00:03:48,780
great for microservices. gRPC's support
for monitoring systems allows them to

47
00:03:48,780 --> 00:03:52,620
alert when your system is unhealthy, and
tracing system support lets you

48
00:03:52,620 --> 00:03:57,060
understand and debug your system as it
grows. tools like interceptors allow you

49
00:03:57,060 --> 00:04:01,860
to share functionality across services
like authentication and logging

50
00:04:01,860 --> 00:04:06,720
gRPC has more advanced features like
streaming, which allows multiple requests

51
00:04:06,720 --> 00:04:11,700
and responses within an RPC
this allows structuring the RPC in a way

52
00:04:11,700 --> 00:04:16,500
more performant for your application
the feature list goes on

53
00:04:16,500 --> 00:04:22,500
gRPC has become very widely adopted
since its 1.0 release in 2016. it is run

54
00:04:22,500 --> 00:04:26,340
at scale at numerous companies and is
continually tested, fuzzed, and

55
00:04:26,340 --> 00:04:30,620
benchmarked to preserve its strong
stability

56
00:04:30,660 --> 00:04:35,280
thank you for watching, I hope this helps
you get started or refreshed with gRPC

57
00:04:35,280 --> 00:04:41,540
you can now check out these websites or
watch other videos in the playlist

58
00:04:56,180 --> 00:04:59,600
thank you

