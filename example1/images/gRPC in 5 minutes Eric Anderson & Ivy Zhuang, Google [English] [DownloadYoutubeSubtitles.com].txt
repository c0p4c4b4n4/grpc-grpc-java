[music]

Hi, I'm Eric Anderson. And I'm Ivy Zhuang. We are Software Engineers on the gRPC
team at Google

We work most on the Java implementation
of gRPC and Proxyless Service Mesh

as an overview, gRPC supports a variety
of languages and platforms with rich

features, making it perfect for
microservices and distributed

applications
gRPC stands for gRPC Remote Procedure

Call. It is a CNCF incubating project
which is the same open-source foundation

as Kubernetes. Fun fact, gRPC also stands
for our golden retriever mascot, pancakes

let me first walk you through a "hello
world" example in gRPC

this is the protobuf file that defines
the API of the service called Greeter

and the request and response message
data structures

for those of you who are new to protocol
buffers, it is an easy and efficient

mechanism to serialize structured data
so that it can be transmitted over wire

specifically, at compile time, the
protobuf generator generates code to

interface with language specific runtime
libraries and the serialization format

for the data that is written to the
network connection

next, you write your application class
based on the protobuf generated source

code that handles a gRPC request
as a demo service, here we attach "Hello"

string and echo the name field in the
request

then we write the code to start the
server application

the main class will start a gRPC server
that is listening on port 50051 for

client connection when it starts running
the last piece of code is the main class

on the client side. it sends a request
through a gRPC channel towards the gRPC

server that we just sprung up
it logs the response data

this concludes our mini demo. this demo
is simple. but this is exactly the same

predecessor library at Google that
supports extremely high qps at the 10 to

the 10th power
with that in mind, let's look at some of

the features of gRPC

gRPC is available in many languages
there's Go, Java, C++, Python, and

many more. gRPC can communicate across
languages with a service definition and

generated code, making the experience
natural in each language

it is also available on many platforms
whether running on Linux, Mac, Windows, or

on mobile devices running iOS and
Android. gRPC can communicate between

them all. you get to choose the language
and platforms for your system

gRPC is built on HTTP/2 which is an IETF
standard. that makes it compatible with

many load balancers and proxies.
HTTP/2 reduces the number of TCP

connections, is binary, it includes header
compression, all of which help make gRPC

high performance, reduce latency, and make
better use of resources

but gRPC also supports direct
client-side load balancing, so when

appropriate, it can run without the
proxies, reducing the number of

components to manage and increasing
performance

This applies even with service meshes. gRPC
has support to directly communicate with

centralized configurations service
discovery servers like Istio and Google

Cloud's Traffic Director that lets it
participate in a mesh without the

headache and cost of sidecar proxies
as you learn gRPC, you'll find it is

great for microservices. gRPC's support
for monitoring systems allows them to

alert when your system is unhealthy, and
tracing system support lets you

understand and debug your system as it
grows. tools like interceptors allow you

to share functionality across services
like authentication and logging

gRPC has more advanced features like
streaming, which allows multiple requests

and responses within an RPC
this allows structuring the RPC in a way

more performant for your application
the feature list goes on

gRPC has become very widely adopted
since its 1.0 release in 2016. it is run

at scale at numerous companies and is
continually tested, fuzzed, and

benchmarked to preserve its strong
stability

thank you for watching, I hope this helps
you get started or refreshed with gRPC

you can now check out these websites or
watch other videos in the playlist

thank you


